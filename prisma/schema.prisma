// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL") // e.g. file:./data/app.db
}

// /* ===================== Ingest: Yandex ===================== */

model YandexArtist {
  id         Int       @id @default(autoincrement())
  ymId       String    @unique
  name       String
  key        String?
  present    Boolean   @default(true)
  lastSeenAt DateTime?
  yGone      Boolean   @default(false)
  yGoneAt    DateTime?
  raw        String?
  updatedAt  DateTime  @updatedAt
  createdAt  DateTime  @default(now())

  mbid String?

  albums YandexAlbum[]

  @@index([name])
  @@index([present])
  @@index([mbid])
}

model YandexAlbum {
  id         Int       @id @default(autoincrement())
  ymId       String    @unique
  title      String
  artist     String?
  year       Int?
  key        String?
  present    Boolean   @default(true)
  lastSeenAt DateTime?
  yGone      Boolean   @default(false)
  yGoneAt    DateTime?
  raw        String?
  updatedAt  DateTime  @updatedAt
  createdAt  DateTime  @default(now())

  yandexArtistId String?
  artistRef      YandexArtist? @relation(fields: [yandexArtistId], references: [ymId], onDelete: SetNull)

  rgMbid String?

  @@index([title])
  @@index([present])
  @@index([yandexArtistId])
  @@index([rgMbid])
}

model YandexTrack {
  ymId        String    @id
  title       String
  artist      String?
  album       String?
  durationSec Int?
  key         String    @unique
  present     Boolean   @default(false)
  lastSeenAt  DateTime?
  yGone       Boolean   @default(false)
  yGoneAt     DateTime?

  ymAlbumId  String?
  ymArtistId String?
  recMbid    String?
  rgMbid     String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // обратная сторона связи для YandexLikeSync.trackRef
  likeSyncs YandexLikeSync[]
}

model YandexLikeSync {
  id                Int       @id @default(autoincrement())
  kind              String
  ymId              String?
  key               String?
  ndId              String?
  status            String    @default("pending")
  source            String    @default("yandex")
  firstSeenAt       DateTime  @default(now())
  lastSeenAt        DateTime  @default(now())
  lastTriedAt       DateTime?
  lastError         String?
  starredAt         DateTime?
  unstarredAt       DateTime?
  starRunId         Int?
  unstarRunId       Int?
  starPlannedAt     DateTime?
  starConfirmedAt   DateTime?
  unstarPlannedAt   DateTime?
  unstarConfirmedAt DateTime?

  // связь на трек; при удалении YandexTrack мы ничего не делаем
  trackRef YandexTrack? @relation(fields: [ymId], references: [ymId])

  @@index([status, lastTriedAt])
  @@index([kind, ymId])
  @@unique([kind, ymId])
}

// /* ===================== Ingest: Lidarr ===================== */

model LidarrArtist {
  id         Int       @id
  mbid       String?
  name       String
  monitored  Boolean   @default(false)
  path       String?
  added      DateTime?
  albums     Int?
  tracks     Int?
  sizeOnDisk Float?
  removed    Boolean   @default(false)
  lastSyncAt DateTime?
  updatedAt  DateTime  @updatedAt
  createdAt  DateTime  @default(now())

  albumsRel LidarrAlbum[]

  @@index([name])
  @@index([mbid])
  @@index([monitored])
  @@index([added])
  @@index([sizeOnDisk])
  @@index([removed])
}

model LidarrAlbum {
  id         Int       @id
  mbid       String?
  title      String
  artistName String?
  path       String?
  monitored  Boolean   @default(false)
  added      DateTime?
  sizeOnDisk Float?
  tracks     Int?
  removed    Boolean   @default(false)
  lastSyncAt DateTime?
  updatedAt  DateTime  @updatedAt
  createdAt  DateTime  @default(now())

  // связь на артиста Lidarr по его numeric id
  artistId  Int?
  artistRef LidarrArtist? @relation(fields: [artistId], references: [id], onDelete: SetNull)

  @@index([title])
  @@index([artistName])
  @@index([mbid])
  @@index([removed])
  @@index([artistId])
}

// /* ===================== Ingest: Custome ===================== */

model CustomArtist {
  id        Int       @id @default(autoincrement())
  name      String
  nkey      String    @unique
  mbid      String?
  matchedAt DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

// /* ===================== MB Sync (трекинг) ===================== */

model MbSyncItem {
  id            Int       @id @default(autoincrement())
  kind          String // 'yandex-artist' | 'yandex-album'
  targetId      Int
  attempts      Int       @default(0)
  lastCheckedAt DateTime?
  lastSuccessAt DateTime?
  lastError     String?

  @@unique([kind, targetId])
  @@index([kind, lastCheckedAt])
}

// /* ===================== Push to Lidarr (кэш статуса) ===================== */

model ArtistPush {
  id             Int      @id @default(autoincrement())
  artistId       Int?
  mbid           String?
  name           String
  path           String?
  lidarrArtistId Int?
  status         String   @default("CREATED")
  attempts       Int      @default(0)
  lastError      String?
  firstPushedAt  DateTime @default(now())
  lastCheckedAt  DateTime @updatedAt
  source         String?

  @@index([status, lastCheckedAt])
  @@index([lidarrArtistId])
  @@index([artistId])
}

model AlbumPush {
  id            Int      @id @default(autoincrement())
  albumId       Int?
  mbid          String?
  title         String
  artistName    String?
  path          String?
  lidarrAlbumId Int?
  status        String   @default("CREATED")
  attempts      Int      @default(0)
  lastError     String?
  firstPushedAt DateTime @default(now())
  lastCheckedAt DateTime @updatedAt
  source        String?

  @@index([status, lastCheckedAt])
  @@index([lidarrAlbumId])
  @@index([albumId])
}

// /* ===================== Cache + Runs/Logs ===================== */

model CacheEntry {
  id        Int       @id @default(autoincrement())
  scope     String // 'ya:artist' | 'ya:album'
  key       String    @unique
  payload   String
  expiresAt DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([scope])
  @@index([expiresAt])
}

model SyncRun {
  id         Int       @id @default(autoincrement())
  kind       String // 'yandex' | 'lidarr' | 'export' | 'match'
  startedAt  DateTime  @default(now())
  finishedAt DateTime?
  status     String // 'running' | 'ok' | 'error'
  stats      String?
  message    String?

  logs SyncLog[]

  @@index([kind, status, startedAt])
}

model SyncLog {
  id      Int      @id @default(autoincrement())
  runId   Int
  ts      DateTime @default(now())
  level   String // 'info' | 'warn' | 'error' | 'debug'
  message String
  data    String?

  run SyncRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId, ts])
  @@index([level, ts])
}

// /* ===================== Settings ===================== */

model Setting {
  id                    Int     @id @default(1)
  lidarrAllowNoMetadata Boolean @default(false)

  backupEnabled   Boolean @default(false)
  backupCron      String?
  backupRetention Int?    @default(14)
  backupDir       String?

  notifyType     String  @default("none")
  telegramBot    String?
  telegramChatId String?
  webhookUrl     String?
  webhookSecret  String?

  yandexDriver String  @default("pyproxy")
  pyproxyUrl   String?

  yandexToken  String?
  lidarrUrl    String?
  lidarrApiKey String?

  mode         String  @default("artists")
  pushTarget   String  @default("artists")
  enableExport Boolean @default(true)
  enablePush   Boolean @default(false)
  exportPath   String?

  rootFolderPath    String?
  qualityProfileId  Int?
  metadataProfileId Int?
  monitor           String?

  cronYandex String  @default("0 */6 * * *")
  cronLidarr String  @default("0 3 * * *")
  yandexCron String?
  lidarrCron String?

  cronCustomMatch String @default("0 0 * * *")
  cronCustomPush  String @default("0 12 * * *")

  cronYandexPull    String @default("0 */6 * * *")
  cronYandexMatch   String @default("10 */6 * * *")
  cronYandexPush    String @default("45 */6 * * *")
  yandexMatchTarget String @default("both") // 'both' | 'artists' | 'albums'
  yandexPushTarget  String @default("both") // 'both' | 'artists' | 'albums'

  cronLidarrPull   String @default("0 3 * * *")
  lidarrPullTarget String @default("both") // 'both' | 'artists' | 'albums'

  enableCronYandexPull  Boolean @default(true)
  enableCronYandexMatch Boolean @default(true)
  enableCronYandexPush  Boolean @default(true)
  enableCronCustomMatch Boolean @default(true)
  enableCronCustomPush  Boolean @default(true)
  enableCronLidarrPull  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  matchRetryDays Int     @default(3)
  allowRepush    Boolean @default(false)

  qbtUrl           String?
  qbtUser          String?
  qbtPass          String?
  qbtDeleteFiles   Boolean @default(true)
  qbtWebhookSecret String?

  navidromeUrl              String?
  navidromeUser             String?
  navidromePass             String?
  navidromeToken            String?
  navidromeSalt             String?
  navidromeSyncTarget       String? // 'artists' | 'albums' | 'tracks' | 'all'
  likesPolicySourcePriority String? // 'yandex' | 'navidrome'
}
