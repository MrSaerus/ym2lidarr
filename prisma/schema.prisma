// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL") // e.g. file:./data/app.db
}

// /* ===================== Ingest: Yandex ===================== */

model YandexArtist {
  id         Int       @id @default(autoincrement())
  ymId       String    @unique
  name       String
  key        String?
  present    Boolean   @default(true)
  lastSeenAt DateTime?
  yGone      Boolean   @default(false)
  yGoneAt    DateTime?
  raw        String?
  updatedAt  DateTime  @updatedAt
  createdAt  DateTime  @default(now())

  mbid          String?
  mbAlbumsCount Int?
  ndId          String?

  albums YandexAlbum[]

  @@index([name])
  @@index([present])
  @@index([mbid])
  @@index([ndId])
}

model YandexAlbum {
  id              Int               @id @default(autoincrement())
  ymId            String            @unique
  title           String
  artist          String?
  year            Int?
  key             String?
  present         Boolean           @default(true)
  lastSeenAt      DateTime?
  yGone           Boolean           @default(false)
  yGoneAt         DateTime?
  raw             String?
  updatedAt       DateTime          @updatedAt
  createdAt       DateTime          @default(now())
  mbLastCheckedAt DateTime?
  torrentState    AlbumTorrentState @default(none)
  genresJson      String?

  yandexArtistId String?
  artistRef      YandexArtist? @relation(fields: [yandexArtistId], references: [ymId], onDelete: SetNull)

  rgMbid String?
  ndId   String?

  tracks YandexTrack[]

  @@index([title])
  @@index([present])
  @@index([yandexArtistId])
  @@index([rgMbid])
  @@index([ndId])
}

model YandexTrack {
  ymId        String    @id
  title       String
  artist      String?
  album       String?
  durationSec Int?
  key         String    @unique
  present     Boolean   @default(false)
  lastSeenAt  DateTime?
  yGone       Boolean   @default(false)
  yGoneAt     DateTime?
  genresJson  String?

  ymAlbumId  String?
  ymArtistId String?
  recMbid    String?
  rgMbid     String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  likeSyncs YandexLikeSync[]

  albumRef YandexAlbum? @relation(fields: [ymAlbumId], references: [ymId])
}

model YandexLikeSync {
  id                Int       @id @default(autoincrement())
  kind              String
  ymId              String?
  key               String?
  ndId              String?
  status            String    @default("pending")
  source            String    @default("yandex")
  firstSeenAt       DateTime  @default(now())
  lastSeenAt        DateTime  @default(now())
  lastTriedAt       DateTime?
  lastError         String?
  starredAt         DateTime?
  unstarredAt       DateTime?
  starRunId         Int?
  unstarRunId       Int?
  starPlannedAt     DateTime?
  starConfirmedAt   DateTime?
  unstarPlannedAt   DateTime?
  unstarConfirmedAt DateTime?

  trackRef YandexTrack? @relation(fields: [ymId], references: [ymId])

  @@index([status, lastTriedAt])
  @@index([kind, ymId])
  @@unique([kind, ymId])
}

// /* ===================== Ingest: Lidarr ===================== */

model LidarrArtist {
  id         Int       @id
  mbid       String?
  name       String
  monitored  Boolean   @default(false)
  path       String?
  added      DateTime?
  albums     Int?
  tracks     Int?
  sizeOnDisk Float?
  removed    Boolean   @default(false)
  lastSyncAt DateTime?
  updatedAt  DateTime  @updatedAt
  createdAt  DateTime  @default(now())

  albumsRel LidarrAlbum[]

  @@index([name])
  @@index([mbid])
  @@index([monitored])
  @@index([added])
  @@index([sizeOnDisk])
  @@index([removed])
}

model LidarrAlbum {
  id         Int       @id
  mbid       String?
  title      String
  artistName String?
  path       String?
  monitored  Boolean   @default(false)
  added      DateTime?
  sizeOnDisk Float?
  tracks     Int?
  removed    Boolean   @default(false)
  lastSyncAt DateTime?
  updatedAt  DateTime  @updatedAt
  createdAt  DateTime  @default(now())

  artistId  Int?
  artistRef LidarrArtist? @relation(fields: [artistId], references: [id], onDelete: SetNull)

  @@index([title])
  @@index([artistName])
  @@index([mbid])
  @@index([removed])
  @@index([artistId])
}

// /* ===================== Ingest: Custom ===================== */

model CustomArtist {
  id            Int       @id @default(autoincrement())
  name          String
  nkey          String    @unique
  mbid          String?
  matchedAt     DateTime?
  mbAlbumsCount Int?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

// /* ===================== MB Sync (трекинг) ===================== */

model MbSyncItem {
  id            Int       @id @default(autoincrement())
  kind          String // 'yandex-artist' | 'yandex-album'
  targetId      Int
  attempts      Int       @default(0)
  lastCheckedAt DateTime?
  lastSuccessAt DateTime?
  lastError     String?

  @@unique([kind, targetId])
  @@index([kind, lastCheckedAt])
}

// /* ===================== Push to Lidarr (кэш статуса) ===================== */

model ArtistPush {
  id             Int      @id @default(autoincrement())
  artistId       Int?
  mbid           String?
  name           String
  path           String?
  lidarrArtistId Int?
  status         String   @default("CREATED")
  attempts       Int      @default(0)
  lastError      String?
  firstPushedAt  DateTime @default(now())
  lastCheckedAt  DateTime @updatedAt
  source         String?

  @@index([status, lastCheckedAt])
  @@index([lidarrArtistId])
  @@index([artistId])
}

model AlbumPush {
  id            Int      @id @default(autoincrement())
  albumId       Int?
  mbid          String?
  title         String
  artistName    String?
  path          String?
  lidarrAlbumId Int?
  status        String   @default("CREATED")
  attempts      Int      @default(0)
  lastError     String?
  firstPushedAt DateTime @default(now())
  lastCheckedAt DateTime @updatedAt
  source        String?

  @@index([status, lastCheckedAt])
  @@index([lidarrAlbumId])
  @@index([albumId])
}

// /* ===================== Cache + Runs/Logs ===================== */

model CacheEntry {
  id        Int       @id @default(autoincrement())
  scope     String // 'ya:artist' | 'ya:album'
  key       String    @unique
  payload   String
  expiresAt DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([scope])
  @@index([expiresAt])
}

model SyncRun {
  id         Int       @id @default(autoincrement())
  kind       String // 'yandex' | 'lidarr' | 'export' | 'match'
  startedAt  DateTime  @default(now())
  finishedAt DateTime?
  status     String // 'running' | 'ok' | 'error'
  stats      String?
  message    String?

  logs SyncLog[]

  @@index([kind, status, startedAt])
}

model SyncLog {
  id      Int      @id @default(autoincrement())
  runId   Int
  ts      DateTime @default(now())
  level   String // 'info' | 'warn' | 'error' | 'debug'
  message String
  data    String?

  run SyncRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId, ts])
  @@index([level, ts])
}

// ===================== Torrents: enums =====================
enum TorrentScope {
  artist
  album
  custom
}

enum TorrentStatus {
  queued
  searching
  found
  added
  downloading
  downloaded
  moving
  moved
  failed
  cancelled
  invalid
}

enum MoveCollisionPolicy {
  ask
  replace
  skip
  merge
}

enum AlbumTorrentState {
  none // ничего не известно / не искали
  searching // есть задача на поиск, но релиз не выбран
  found // релиз найден/выбран, но ещё не качаем
  downloading // добавлено в qBittorrent, идёт загрузка
  downloaded // скачано/перемещено, готово
}

// ===================== Torrents: core models =====================
model TorrentTask {
  id            Int                  @id @default(autoincrement())
  scope         TorrentScope
  artistId      Int?
  albumId       Int?
  query         String?
  status        TorrentStatus        @default(queued)
  qbitHash      String?              @unique
  indexerId     Int?
  indexerRef    JackettIndexer?      @relation(name: "IndexerToTasks", fields: [indexerId], references: [id], onDelete: SetNull)
  title         String?
  size          BigInt?
  seeders       Int?
  quality       String?
  finalPath     String?
  movePolicy    MoveCollisionPolicy? @default(replace)
  startedAt     DateTime?
  finishedAt    DateTime?
  lastError     String?
  retries       Int                  @default(0)
  minSeeders    Int?
  limitReleases Int?
  scheduledAt   DateTime?
  lastTriedAt   DateTime?
  taskKey       String?              @unique
  releases      TorrentRelease[]
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt
  artistName    String?
  albumTitle    String?
  albumYear     Int?
  ymArtistId    String?
  ymAlbumId     String?
  ymTrackId     String?
  layout        String?              @default("unknown")

  @@index([status])
  @@index([artistId])
  @@index([albumId])
  @@index([indexerId])
  @@index([scheduledAt])
  @@index([ymArtistId])
  @@index([ymAlbumId])
  @@index([ymTrackId])
}

model TorrentRelease {
  id         Int             @id @default(autoincrement())
  taskId     Int
  task       TorrentTask     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  indexerId  Int?
  indexerRef JackettIndexer? @relation(name: "IndexerToReleases", fields: [indexerId], references: [id], onDelete: SetNull)
  title      String
  link       String?
  magnet     String?
  size       BigInt?
  seeders    Int?
  leechers   Int?
  pubDate    DateTime?
  quality    String?
  score      Float           @default(0)
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  status     String          @default("new")

  @@index([taskId])
  @@index([indexerId])
  @@index([seeders, score])
  @@index([pubDate])
  @@unique([taskId, magnet])
}

// /* ===================== Settings ===================== */

model Setting {
  id                    Int     @id @default(1)
  lidarrAllowNoMetadata Boolean @default(false)

  backupEnabled   Boolean @default(false)
  backupCron      String?
  backupRetention Int?    @default(14)
  backupDir       String?

  notifyType     String  @default("none")
  telegramBot    String?
  telegramChatId String?
  webhookUrl     String?
  webhookSecret  String?

  yandexDriver String  @default("pyproxy")
  pyproxyUrl   String?

  yandexToken  String?
  lidarrUrl    String?
  lidarrApiKey String?

  mode         String  @default("artists")
  pushTarget   String  @default("artists")
  enableExport Boolean @default(true)
  enablePush   Boolean @default(false)
  exportPath   String?

  rootFolderPath    String?
  qualityProfileId  Int?
  metadataProfileId Int?
  monitor           String?

  cronYandex String  @default("0 */6 * * *")
  cronLidarr String  @default("0 3 * * *")
  yandexCron String?
  lidarrCron String?

  cronCustomMatch String @default("0 0 * * *")
  cronCustomPush  String @default("0 12 * * *")

  cronYandexPull    String @default("0 */6 * * *")
  cronYandexMatch   String @default("10 */6 * * *")
  cronYandexPush    String @default("45 */6 * * *")
  yandexMatchTarget String @default("both")
  yandexPushTarget  String @default("both")

  cronLidarrPull   String @default("0 3 * * *")
  lidarrPullTarget String @default("both")

  cronTorrentRunUnmatched   String @default("*/15 * * * *")
  cronTorrentQbtPoll        String @default("*/5 * * * *")
  cronTorrentCopyDownloaded String @default("*/5 * * * *")

  enableCronTorrentRunUnmatched   Boolean @default(false)
  enableCronTorrentQbtPoll        Boolean @default(false)
  enableCronTorrentCopyDownloaded Boolean @default(false)

  enableCronYandexPull    Boolean @default(false)
  enableCronYandexMatch   Boolean @default(false)
  enableCronYandexPush    Boolean @default(false)
  enableCronCustomMatch   Boolean @default(false)
  enableCronCustomPush    Boolean @default(false)
  enableCronLidarrPull    Boolean @default(false)
  enableCronNavidromePush Boolean @default(false)

  torrentRunUnmatchedLimit            Int? // limit
  torrentRunUnmatchedMinSeeders       Int? // minSeeders
  torrentRunUnmatchedLimitPerIndexer  Int? // limitPerIndexer
  torrentRunUnmatchedAutoStart        Boolean? @default(false) // autoStart
  torrentRunUnmatchedParallelSearches Int? // concurrency
  torrentQbtPollBatchSize             Int?
  torrentCopyBatchSize                Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  matchRetryDays Int     @default(3)
  allowRepush    Boolean @default(false)

  torrentJackettQbtBaseUrl String?
  torrentQbtCategory       String  @default("YM2LIDARR")
  qbtUrl                   String?
  qbtUser                  String?
  qbtPass                  String?
  qbtDeleteFiles           Boolean @default(true)
  qbtWebhookSecret         String?

  navidromeUrl              String?
  navidromeUser             String?
  navidromePass             String?
  navidromeToken            String?
  navidromeSalt             String?
  navidromeSyncTarget       String?
  likesPolicySourcePriority String?
  cronNavidromePush         String?

  yandexMatchForce Boolean? @default(false)
  customMatchForce Boolean? @default(false)
  mbMatchForce     Boolean? @default(false)

  torrentDownloadsDir String? @default("/home/Downloads")
  musicLibraryDir     String? @default("/home/Music")

  musicArtistFolderPattern String? @default("{Artist}")
  musicAlbumFolderPattern  String? @default("{Year} - {Album}")
  musicTrackFilePattern    String? @default("{Track:2} - {Title}")
  musicVariousArtistsName  String? @default("Various Artists")
  musicDiscFolderPattern   String? @default("Disc {Disc}")

  fileOpMode String? @default("copy") // "copy" | "hardlink" | "move"

  copyInProgress Boolean @default(false)
}

model JackettIndexer {
  id                Int       @id @default(autoincrement())
  name              String
  enabled           Boolean   @default(true)
  allowRss          Boolean   @default(true)
  allowAuto         Boolean   @default(true)
  allowInteractive  Boolean   @default(true)
  baseUrl           String
  apiKey            String
  categories        Json?
  tags              String?
  minSeeders        Int?
  order             Int       @default(100)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  errorCount        Int       @default(0)
  tempDisabledUntil DateTime?

  tasks    TorrentTask[]    @relation(name: "IndexerToTasks")
  releases TorrentRelease[] @relation(name: "IndexerToReleases")

  @@index([enabled, order])
  @@index([name])
}
